# Lattices

## Vectors

Nothing much to be done here. Just defined my own functions for the operations and solved it.

### Given

$$
\begin{split}
v = (2,6,3)\\
w = (1,0,0)\\
u = (7,7,2)\\
\end{split}
$$

### Solving

$$
\begin{split}
3 \cdot (2 \cdot v - w) \cdot 2 \cdot u = 702
\end{split}
$$

## Size and Basis

Once again, pretty basic. Did the same thing again and solved it.

### Given

$$
\begin{split}
v = (4,6,2,5)
\end{split}
$$

### Solving

$$
\begin{split}
size(v) = \sqrt{v \cdot v} = 9
\end{split}
$$

## Gram Schmidt

Given a basis $v_{1},v_{2},…,v_{n} ∈ V$ for a vector space, the Gram-Schmidt algorithm calculates an orthogonal basis $u_{1},u_{2},…,u_{n} ∈ V$.
This was a simple algorithm to implement, with only a few errors occuring when I set the loop bounds wrong.
Of course, I had already studied this in my Mathematics course, so not a challenging problem.

### Given

$$
\begin{split}
v_{1} = (4,1,3,-1)\\
v_{2} = (2,1,-3,4)\\
v_{3} = (1,0,-2,7)\\
v_{4} = (6,2,9,-5)\\
\end{split}
$$

### Solving

The flag here is the float value of the second component of $u_{4}$ to 5 significant figures.

The orthogonal basis obtained through Gram-Schmidt is:

$$
\begin{split}
u_{1} &= (0.769800358919501, 0.19245008972987526, 0.5773502691896257, -0.19245008972987526)\\
u_{2} &= (0.47808586842086204, 0.21172374172923888, -0.47125607030056393, 0.710299004510995)\\
u_{3} &= (-0.22709712023395856, -0.32046806165419245, 0.6322320524980238, 0.6678396149040454)\\
u_{4} &= (-0.35674669978168144, 0.9030150838223783, 0.21181835299537438, 0.1114833436817765)\\
\end{split}
$$

I kind of made an idiotic mistake here at the end.
Instead of rounding it, I cut it off at the 5th significant figure, which made me keep submitting the wrong answer.
Eventually I figured it out and gave the proper rounded answer of 90302.

## What's a Lattice?

This part introduced the concept of a lattice.
Given a set of linearly independent vectors $v_{1},v_{2},…,v_{n} ∈ R^m$, the lattice $L$ generated by $v_{1},v_{2},…,v_{n}$​ is the set of linearly independent vectors $v_{1},v_{2},…,v_{n}$​ with integer coefficients.

That is,

$$
\begin{split}
L = a_{1} \cdot v_{1} + a_{2} \cdot v_{2} + \dots + a_{k} \cdot v_{k}
\end{split}
$$

where $a_{1},a_{2},\dots,a_{n} ∈ \mathbb{Z}$

Here, the basis for the lattice is any set of independent vectors that can generate it.

What's being asked of us here is to calculate the volume of the fundamental domain.
Volume is the magnitude of the determinant of the matrix with rows corresponding to the basis vectors.

### Given

The basis vectors are:

$$
\begin{split}
v_{1} &= (6,2,-3)\\
v_{2} &= (5,1,4)\\
v_{3} &= (2,7,1)\\
\end{split}
$$

### Solving

I coded the algorithm for finding the determinant of a n-dimensional matrix myself.
It was a simple one, but I was surprised at how so many errors could pop up while doing such a small thing.

$$
\begin{split}
vol(F(v_{1},v_{2},v_{3})) &= |det(A)|\\
&= 255
\end{split}
$$

## Gaussian Reduction

Here, both the **Shortest Vector Problem(SVP)** and the **Closest Vector Problem(CVP)** were introduced.

**Shortest Vector Problem(SVP)**: find the shortest non-zero vector in a lattice $L$. In other words, find the non-zero vector within $v ∈ L$ such that $||v||$ is minimised.

**Closest Vector Problem(CVP)**: Given a vector $w ∈ R^m$ that is not in $L$, find the vector $v ∈ L$ that is the closest to $w$, i.e. find the vector $v ∈ L$ such that $||v−w||$ is minimised.

Gaussian Lattice Reduction was developed to find an optimal basis for a two-dimensional lattice given an arbitrary basis, in which the output $v_{1}$ is a shortest non-zero vector in $L$ and thus solves the SVP.

### Given

$$
\begin{split}
v &= (846835985,9834798552)\\
u &= (87502093,123094980)\\
\end{split}
$$

### Solving

This was somewhat similar to Euclid's algorithm, since we swap to ensure the one with smaller size stays as $v_{1}$.

The optimal basis obtained is:

$$
\begin{split}
v_{1} &= (87502093,123094980)\\
v_{2} &= (-4053281223, 2941479672)\\
\end{split}
$$

The dot product, $v_{1} \cdot v_{2} = 7410790865146821$

## Find The Lattice

### Given

#### Key Generation

- $q$ is some 512-bit prime number
- $2<f<\sqrt{\frac{q}{2}}$
- $\sqrt{\frac{q}{4}}<g<\sqrt{\frac{q}{2}}$ and $gcd(f,g)=1$
- $h = f^{-1} \cdot g \mod q$ 
- Now `gen_key()` returns `(q, h), (f, g)`

Here, $(q,h)$ is the public key and $(f,g)$ is the private key.

#### Encryption

- $m<\sqrt{\frac{q}{2}}$ 
- $2<r<\sqrt{\frac{q}{2}}$
- $e=r \cdot h + m \mod q$
- Now, `encrypt(q, h, m)` returns `e`

Here, `(q, h)` is the public key generated, `m` the message to be encrypted, and `e` the encrypted message.

#### Decryption

- $a=f \cdot e \mod q$
- $m=a \cdot f^{-1} \mod g$
- Now, `decrypt(q, h, f, g, e)` returns `m`

Here, `(q, h)` is the public key generated, `(f, g)` the private key, `e` the encrypted message, and `m` the original message.

### Solving

What we need to find is the private key, $(f,g)$.
Once we get that, we can easily decrypt the flag with the given procedure.

We need to find some sort of way to turn this into a lattice problem. 

$$
\begin{split}
h &= f^{-1} \cdot g \mod q\\
\iff g &= f \cdot h \mod q\\
\iff g &= f \cdot h + k \cdot q\\
\iff (g,f) &= (fh + kq,f)\\
\iff (g,f) &= f(h,1) + k(q,0)\\
\end{split}
$$

where $k$ is some integer.

This shows that $(g,f)$ is a linear combination of the vectors $(h,1)$ and $(q,0)$.

Let's consider the lattice constructed by the basis, $B = ((q,0),(h,1))$.
The vector $(g,f)$ lies in this lattice.
Since both $f$ and $g$ are bounded by $\sqrt{q/2}$, the vector has norm $= \sqrt{f^2 + g^2} \approx \sqrt{q}$.
This is quite smaller than the other basis vectors, which have norms on the order of $q$.

So here, we could use Gaussian Reduction to get the optimal basis, from which we'll get the SVP, which gives us the private key.

## Backpack Cryptography

I originally had no clue what to make of the source code, but when I searched up "Backpack Cryptography" on the internet, the first thing that popped up was the Merkle-Hellman knapsack cryptosystem.
There were also multiple sources for the lattice reduction attack on this system, so I was thankfully able to understand the concept behind this.

Merkle-Hellman is a public key cryptosystem based on the subset sum problem.
The problem is as follows: given a set of integers $A$ and an integer $c$, find a subset of $A$ that sums to $c$.

### Given

#### Key Generation

##### Private Key

First, we have an initial value of $s=10000$.
We generate a superincreasing sequence `b[]` with `size` number of elements.
Each $b[i]$ is randomly chosen from $(s+1, 2s)$, with the superincreasing property($b[i] > sum(b[0:i])$).
We keep updating $s$ to $s += b[i]$ in this loop.

We then randomly choose a prime `q` from $(2s, 32s)$ and a random integer `r` from $(s,q)$.

Then we return the private key, which is `(b, r, q)`.

##### Public Key

The public key is based on the private key `b[ ]`.

It is `a[]` where $a[i] = r \cdot b[i] \mod q$.

#### Encryption

Initialise ciphertext to 0.
We convert the message `m` to binary and then, for each bit `a[i]` in the private key, we add `a[i]*m[i]` to ciphertext.
We then return the final sum.

#### Decryption

We first compute $ct' = r^{-1} \cdot ct \mod q$.
Initialise message to 0.
Now we start from the end of the private key `b[]`, that is, the largest element.
If $ct' >= b[i]$, we set the $i^{th}$ bit of the message to 1 and subtract $b[i]$ from $ct'$.

### Solving